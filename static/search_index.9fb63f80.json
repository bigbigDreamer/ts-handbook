[{"id":0,"title":"博客","content":"#\n\n\n里程碑#\n\n公元2024年7月9日，本站点创建了。","routePath":"/blog","lang":"","toc":[{"text":"里程碑","id":"里程碑","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"立即开始","content":"#\n\n在开始使用之前，我们建议你阅读以下介绍性页面之一。这些介绍旨在突出 TypeScript\n与你喜欢的编程语言之间的主要相似之处和不同之处，并澄清针对这些语言的常见误解。\n\n * 面向新程序员的 TypeScript\n\n * 面向 JavaScript 程序员的 TypeScript\n\n * 面向 Java/C# 程序员的 TypeScript\n\n * 面向函数式程序员的 TypeScript","routePath":"/guide/handbook/about","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"基础","content":"#\n\n欢迎来到手册的第一页。\n\nJavaScript 中，每一个值都有一组行为，您可以通过运行不同的操作来观察到。这听起来很抽象，但举个简单的例子，考虑一下我们可能对名为 message\n的变量运行的一些操作。\n\n\n\n我们对此进行分解，第一行可运行的代码访问了一个名为 toLowerCase 的属性，然后调用了它。第二行则试图直接调用 message 。\n\n但是假设我们不知道 message\n的值——这是很常见的——我们就不能可靠地说尝试运行这段代码中的任何一行会得到什么结果。每个操作的行为完全取决于我们最初拥有的值。\n\nmessage 是可调用的吗？\n\n它上面有一个名为 toLowerCase 的属性吗？\n\n如果有，toLowerCase 甚至是可调用的吗？\n\n如果这两个值都是可调用的，它们返回什么？\n\n在编写 JavaScript 时，这些问题的答案通常是我们要牢记于心的，并且我们得希望我们把所有细节都弄对了。\n\n假设 message 是以以下方式定义的。\n\n\n\n您可能猜到的，如果我们尝试运行 message.toLowerCase() ，我们将得到相同的字符串，只是变成小写。\n\n那关于第二行代码呢？如果您熟悉 JavaScript ，您就会知道这会因异常而失败：\n\n\n\n我们能避免这样的错误，那就太好了。\n\n当我们运行代码时，我们的 JavaScript 运行时决定如何操作的方式是通过确定值的类型——它具有什么样的行为和能力。这就是那个 TypeError\n所暗示的部分内容——它表示字符串 \"Hello World!\" 不能作为函数被调用。\n\n对于某些值，例如基本类型字符串和数字，我们可以在运行时使用 typeof\n操作符来确定它们的类型。但对于其他东西，比如函数，没有相应的运行时机制来确定它们的类型。例如，考虑这个函数：\n\n\n\n阅读代码我们可以观察到，只有在给定具有可调用 “flip” 属性的对象时，此函数才会起作用，但 JavaScript\n并未以我们在代码运行时可以检查的方式显示此信息。在纯 JavaScript 中，要了解特定值下 fn\n的作用，唯一的方法是调用它并查看发生了什么。这种行为使得在代码运行之前很难预测它会做什么，这意味着在编写代码时更难知道您的代码将会做什么。\n\n从这个角度来看，类型是描述哪些值可以传递给 fn 以及哪些会导致崩溃的概念。JavaScript 实际上只提供动态类型——运行代码以查看会发生什么。\n\n另一种选择是使用静态类型系统，在代码运行之前对其预期行为进行预测。","routePath":"/guide/handbook/basic","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"深入了解函数","content":"#","routePath":"/guide/handbook/more-on-function","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"类型缩小","content":"#","routePath":"/guide/handbook/narrowing","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"对象类型","content":"#","routePath":"/guide/handbook/object-types","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"从类型中创建类型","content":"#","routePath":"/guide/handbook/type-manipulation/create-types-from-types","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"泛型","content":"#","routePath":"/guide/handbook/type-manipulation/generics","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"常用类型","content":"#","routePath":"/guide/handbook/usual-types","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"关于本指南","content":"#\n\n本指南的初衷是“扫盲” & 创意式翻译官方的 TS HandBook。\n\n有些内容会略微进行删减，只翻译记录干货，尽量聚焦在核心知识点上，各个章节提供代码示例。\n\n本指南如果能对你有所帮助，欢迎在 GitHub 为本仓库点一个 Star，如果有勘误，欢迎 Issue 或者 PR。\n\n最后，旅程即将开始，希望你有所收获！","routePath":"/guide/start/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"介绍","content":"#","routePath":"/guide/start/intro","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"致谢","content":"#\n\n本站的创建离不开以下站点及个人，本站声明不附带任何盈利性质，所有内容一经发布默认进入公共领域，所有内容遵循 Unlicense 协议。\n\nINFO\n\n本站仅供学习交流、欣赏使用。本站不对内容正确性负责，如有勘误可留言交流或者提 PR 处理~\n\n\n站点框架#\n\n * Rspress\n\n\n图标来源#\n\n * iconfont.cn\n\n\n网站托管#\n\n * GitHub Pages\n * Cloudflare","routePath":"/thxfor","lang":"","toc":[{"text":"站点框架","id":"站点框架","depth":3,"charIndex":125},{"text":"图标来源","id":"图标来源","depth":3,"charIndex":145},{"text":"网站托管","id":"网站托管","depth":3,"charIndex":169}],"domain":"","frontmatter":{},"version":""}]