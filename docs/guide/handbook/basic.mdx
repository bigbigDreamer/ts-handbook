# 基础

欢迎来到手册的第一页。

`JavaScript` 中，每一个值都有一组行为，您可以通过运行不同的操作来观察到。这听起来很抽象，但举个简单的例子，考虑一下我们可能对名为 `message` 的变量运行的一些操作。

```javascript
// Accessing the property 'toLowerCase'
// on 'message' and then calling it
message.toLowerCase();
// Calling 'message'
message();

```

我们对此进行分解，第一行可运行的代码访问了一个名为 `toLowerCase` 的属性，然后调用了它。第二行则试图直接调用 `message` 。

但是假设我们不知道 `message` 的值——这是很常见的——我们就不能可靠地说尝试运行这段代码中的任何一行会得到什么结果。每个操作的行为完全取决于我们最初拥有的值。

`message` 是可调用的吗？

它上面有一个名为 `toLowerCase` 的属性吗？

如果有，`toLowerCase` 甚至是可调用的吗？

如果这两个值都是可调用的，它们返回什么？

在编写 `JavaScript` 时，这些问题的答案通常是我们要牢记于心的，并且我们得希望我们把所有细节都弄对了。

假设 `message` 是以以下方式定义的。


```typescript
const message = "Hello World!";
```

您可能猜到的，如果我们尝试运行 `message.toLowerCase()` ，我们将得到相同的字符串，只是变成小写。

那关于第二行代码呢？如果您熟悉 `JavaScript` ，您就会知道这会因异常而失败：

```shell
TypeError: message is not a function
```

我们能避免这样的错误，那就太好了。

当我们运行代码时，我们的 `JavaScript` 运行时决定如何操作的方式是通过确定值的类型——它具有什么样的行为和能力。这就是那个 `TypeError` 所暗示的部分内容——它表示字符串 ``"Hello World!"`` 不能作为函数被调用。

对于某些值，例如基本类型字符串和数字，我们可以在运行时使用 `typeof` 操作符来确定它们的类型。但对于其他东西，比如函数，没有相应的运行时机制来确定它们的类型。例如，考虑这个函数：

```typescript
function fn(x) {
  return x.flip();
}
```

阅读代码我们可以观察到，只有在给定具有可调用 `“flip”` 属性的对象时，此函数才会起作用，但 `JavaScript` 并未以我们在代码运行时可以检查的方式显示此信息。在纯 `JavaScript` 中，要了解特定值下 `fn` 的作用，唯一的方法是调用它并查看发生了什么。这种行为使得在代码运行之前很难预测它会做什么，这意味着在编写代码时更难知道您的代码将会做什么。

从这个角度来看，类型是描述哪些值可以传递给 `fn` 以及哪些会导致崩溃的概念。`JavaScript` 实际上只提供动态类型——运行代码以查看会发生什么。

另一种选择是使用静态类型系统，在代码运行之前对其预期行为进行预测。
